// Each #kernel tells which function to compile; you can have many kernels

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
// RWTexture2D<float4> Result;




#pragma kernel DrawLine

struct Line
{
    float2 _start;
    float2 _end;
    float4 _color;
};

RWStructuredBuffer<Line> LineBuffer;
RWTexture2D<float4> OutTexture;
int width;
int height;


[numthreads(8,1,1)]
void DrawLine (uint3 id : SV_DispatchThreadID)
{
    Line l = LineBuffer[id.x];

    int w = l._end.x - l._start.x ;
    int h = l._end.y - l._start.y ;
    int dx1 = sign(w), dx2 = dx1, dy1 = sign(h), dy2 = 0 ;
    int longest = abs(w) ;
    int shortest = abs(h) ;
    if (!(longest>shortest)) {
        longest = abs(h) ;
        shortest = abs(w) ;
        dy2 = dy1;
        dx2 = 0;
    }
    int numerator = longest >> 1 ;
    for (int i=0, x = l._start.x, y = l._start.y;i<=longest;i++) {
        OutTexture[int2(x,y)] = l._color;
        numerator += shortest ;
        if (!(numerator<longest)) {
            numerator -= longest ;
            x += dx1 ;
            y += dy1 ;
        } else {
            x += dx2 ;
            y += dy2 ;
        }
    }


    //1st quadrant only
    // int2 p1 = (int2)l._start;
    // int2 p2 = (int2)l._end;
    // int m = 2 * ( p2.y - p1.y );
    // int slopeError = m - ( p2.x - p1.x );

    // for(int x = p1.x, y = p1.y; x <= p2.x; x++)
    // {
    //     OutTexture[int2(x,y)] = l._color;
    //     slopeError += m;
    //     if(slopeError >= 0)
    //     {
    //         y++;
    //         slopeError -= 2 * ( p2.x - p1.x );
    //     }
    // }

    // // Breseham unoptimized
    // float deltaX = l._end.x - l._start.x;
    // float deltaY = l._end.y - l._start.y;
    // if( deltaX == 0 ) return; //straight line
    // float deltaError = abs(deltaY/deltaX);
    // float error = 0;
    // int y = (int)l._start.x;
    // int lenghtX = (int)abs(deltaX);
    // for(int x = l._start.x; x < l._end.x; x++)
    // {
    //     OutTexture[int2(x+l._start.x,y)] = l._color;
    //     error += deltaError;
    //     if(error>.5)
    //     {
    //         y+= sign(deltaY);
    //         error-=1;
    //     }
    // }


    // // naive implementation
    // float2 lenghts = abs(l._start - l._end);
    // bool lineIsTall = lenghts.x<lenghts.y;
    // //render
    // if(lineIsTall)
    // {
    //     for(int y=0; y<(int)lenghts.y; y++)
    //     {
    //             int2 pos = lerp(l._start,l._end,(float)(y/lenghts.y));
    //             OutTexture[pos] = l._color;
    //     }
    // } else {
    //     for(int x=0; x<(int)lenghts.x; x++)
    //     {
    //             int2 pos = lerp(l._start,l._end,(float)(x/lenghts.x));
    //             OutTexture[pos] = l._color;
    //     }
    // }


    // render ends
    // for( int x=-1; x<=1; x++ )
    // {
    //     for( int y=-1; y<=1; y++ )
    //     {
    //         int2 pos = int2(x,y)+l._start;
    //         OutTexture[pos] = l._color;
    //     }
    // }
    // for( int x=-1; x<=1; x++ )
    // {
    //     for( int y=-1; y<=1; y++ )
    //     {
    //         int2 pos = int2(x,y)+l._end;
    //         OutTexture[pos] = l._color;
    //     }
    // }

    // //identify corners
    // OutTexture[int2( 0      , 0        )] = float4(1.,1.,1.,1.);
    // OutTexture[int2( width-1, 0        )] = float4(1.,0.,0.,1.);
    // OutTexture[int2( 0      , height-1 )] = float4(0.,1.,0.,1.);
    // OutTexture[int2( width-1, height-1 )] = float4(1.,1.,0.,1.);
}

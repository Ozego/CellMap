#pragma kernel Clear
#pragma kernel GetHead
#pragma kernel GetHeadsOnGrid
#pragma kernel GetHeadsOnLine
#pragma kernel DrawHeads
#include "rngInclude.compute"
#include "TrigConst.compute"

struct Head
{
    float2  position;
    float2  direction;
    float   speed;
    float   angularMomentum;
    uint    state;
};
/*
Tag                             Name                                            */
RWTexture2D<float4>             LineMap;
AppendStructuredBuffer<Head>    HeadAppendBuffer;
ConsumeStructuredBuffer<Head>   HeadConsumeBuffer;
int2    Size;
int     Frame;
int     gridSize;
float   initialSpeed;
float   initialDirection;
float   initialDirectionVariation;
float   lineSpawnChance;
float   lineAcceleration;
float   lineSpawnAcceleration;
float   lineVariation;
float   lineSpawnVariation;
float   lineAngularAcceleration;
float   lineSpawnAngularAcceleration;
float   lineAngularVariation;
float   lineSpawnAngularVariation;
float   spawnAngle;
float   spawnAngleVariation;
int     boolArray;

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    // LineMap[id.xy] = LineMap[id.xy]*.75;
    LineMap[id.xy] = float4( 0.0, 0.0, 0.0, 0.0 );
}
[numthreads(8,8,1)]
void GetHead (uint3 id : SV_DispatchThreadID)
{
    if( id.x == Size.x/2 & id.y == Size.y/2 )
    {
        Head newHead;
        newHead.position            = (float2)id.xy ;
        float angle = ( initialDirection + ( rng2D( id.xy, Frame + 0x2111 ) - .5 ) * initialDirectionVariation ) * PI ;
        newHead.direction           = float2( sin( angle ), cos( angle ) );
        newHead.speed               = initialSpeed;
        newHead.angularMomentum     = 0.;
        newHead.state               = 1;
        HeadAppendBuffer.Append(newHead);
    }
}
[numthreads(8,8,1)]
void GetHeadsOnGrid (uint3 id : SV_DispatchThreadID)
{
    if( id.y % gridSize == 0 & id.x % gridSize == 0)
    {
        Head newHead;
        newHead.position            = (float2)id.xy + ( rng2DVector2( id.xy , Frame + 0x1111 ) - .5 ) * gridSize;
        float angle = ( initialDirection + ( rng2D( id.xy, Frame + 0x2111 ) - .5 ) * initialDirectionVariation ) * PI ;
        newHead.direction           = float2( sin( angle ), cos( angle ) );
        newHead.speed               = initialSpeed;
        newHead.angularMomentum     = 0.;
        newHead.state               = 1;
        HeadAppendBuffer.Append(newHead);
    }
}
[numthreads(8,8,1)]
void GetHeadsOnLine (uint3 id : SV_DispatchThreadID)
{
    if( id.y != 10) return;
    // LineMap[ id.xy ] = float4( 1.0, 0.0, 0.0, 1.0 );
    if( id.x % gridSize == 0)
    {
        Head newHead;
        newHead.position            = (float2)id.xy + float2( rng2D( id.xy , Frame + 0x1111 ) - .5 , 0.) * gridSize ;
        float angle = ( initialDirection + ( rng2D( id.xy, Frame + 0x2111 ) - .5 ) * initialDirectionVariation ) * PI ;
        newHead.direction           = float2( sin( angle ), cos( angle ) );
        newHead.speed               = initialSpeed;
        newHead.angularMomentum     = 0.;
        newHead.state               = 1;
        HeadAppendBuffer.Append(newHead);
    }
    
}
[numthreads(8,8,1)]
void DrawHeads (uint3 id : SV_DispatchThreadID)
{
    Head consumeHead = HeadConsumeBuffer.Consume();
    if( consumeHead.state == 0) return;                                         //If null return
    if( consumeHead.speed < 1.5 ) return;                                        //If stationary return
    
    float2 traversal = consumeHead.direction * consumeHead.speed;

    int dx1 = sign( traversal.x ), dx2 = dx1, dy1 = sign( traversal.y ), dy2 = 0;
    int longest  = abs( traversal.x );
    int shortest = abs( traversal.y );
    if (!(longest>shortest)) 
    {
        longest  = abs( traversal.y );
        shortest = abs( traversal.x );
        dy2 = dy1;
        dx2 = 0;
    }
    int numerator = longest >> 1;                                               // bitwise halfing
    for (int i=0, x = consumeHead.position.x, y = consumeHead.position.y; i <= longest; i++ ) 
    {
        int modX = ( x % Size.x + Size.x ) % Size.x;
        int modY = ( y % Size.y + Size.y ) % Size.y;
                                                                                //TODO: Detect diagonal Lines intersection
        if(LineMap[ int2( modX, modY ) ].a == 1. && i!=0 ) return;              //If traversing existing cell return
        
        LineMap[ int2( modX, modY ) ] = float4( 1., 1., 1., 1. );               //Draw on map
        numerator += shortest;
        if ( !( numerator < longest ) ) {
            int modDX = ( (x + dx2) % Size.x + Size.x ) % Size.x;
            int modDY = ( (y + dy2) % Size.y + Size.y ) % Size.y;
            if(LineMap[ int2( modDX, modDY ) ].a == 1. && i!=0 ) return;        //If shifting shortest check non-shifted cell to check for diagonal line traversal
            numerator -= longest;
            x += dx1;
            y += dy1;
        } else {
            x += dx2;
            y += dy2;
        }
    }

    Head appendHead;
    float a = atan2(consumeHead.direction.x,consumeHead.direction.y);
    appendHead.angularMomentum  = (rng2D( id.xy, Frame + 0x4111 )-.5) * lineAngularVariation + consumeHead.angularMomentum * lineAngularAcceleration;
    a += appendHead.angularMomentum;
    appendHead.direction        = float2(sin(a),cos(a));
    appendHead.position         = consumeHead.position + consumeHead.direction * consumeHead.speed;
    appendHead.speed            = consumeHead.speed * lineAcceleration + ( rng2D( id.xy, Frame + 0x5111 ) * 2. - 1. ) * lineVariation ;
    appendHead.state            = 1;
    HeadAppendBuffer.Append(appendHead);

    if(rng2D( id.xy, Frame + 0x1EEF ) > lineSpawnChance)
    {
        Head appendHeadChild;
        float invSign = 1.;
        if ( boolArray^0xFFFE == 0x1EDD) invSign = sign( rng2D( id.xy,Frame + 0x6111 ) - 0.5 );
        a += PI * invSign * ( spawnAngle + ( rng2D( id.xy, Frame + 0x1C33 ) - .5 ) * spawnAngleVariation );
        appendHeadChild.direction       = float2(sin(a),cos(a)); //normalize( consumeHead.direction * lineSpawnAngularAcceleration + rngVector2(  id.x + ( id.y << 4 ), Frame + 256 ) * lineSpawnAngularVariation);
        appendHeadChild.position        = consumeHead.position + consumeHead.direction * consumeHead.speed;
        appendHeadChild.speed           = consumeHead.speed * lineSpawnAcceleration + ( rng2D( id.xy, Frame + 0x1E89 ) * 2. - 1. ) * lineSpawnVariation ;
        appendHeadChild.angularMomentum = (rng2D( id.xy, Frame + 0x1E95 )-.5) * lineSpawnAngularVariation + invSign * appendHead.angularMomentum * lineSpawnAngularAcceleration;
        appendHeadChild.state           = 1;
        HeadAppendBuffer.Append(appendHeadChild);
    }
}

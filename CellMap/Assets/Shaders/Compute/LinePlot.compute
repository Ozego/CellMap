#pragma kernel Clear
#pragma kernel GetHeads
#pragma kernel DrawHeads
#include "rngInclude.compute"
#define GRIDWIDTH 1024

struct Head
{
    float2  position;
    float2  direction;
    float   speed;
    uint    state; // 0b0000000000000000 is dead
};
/*
HeightMap Structure:
Red     Blue    Green   Alpha
Height  ddX     ddY     Unmapped

Tag                             Name                                            */
RWTexture2D<float4>             FilterMap;
AppendStructuredBuffer<Head>    HeadAppendBuffer;
ConsumeStructuredBuffer<Head>   HeadConsumeBuffer;
int2                            Size;
int                             Frame;
int                             lDensity;
float                           clInertia;
float                           slInertia;
float                           clChaos;
float                           slChaos;
float                           cInertia;
float                           sInertia;
float                           cChaos;
float                           sChaos;

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    // FilterMap[id.xy] = FilterMap[id.xy]*.75;
    FilterMap[id.xy] = float4( 0.5, 0.5, 0., 0. );
}
[numthreads(8,8,1)]
void GetHeads (uint3 id : SV_DispatchThreadID)
{
    // uint2 noiseDimensions;
    // BlueNoise.GetDimensions( noiseDimensions.x , noiseDimensions.y );
    // float4 noiseVal = BlueNoise[ id.xy % noiseDimensions ];
    // [branch] if(noiseVal.r>.99)

    if( id.y % GRIDWIDTH == 0 & id.x % GRIDWIDTH == 0)
    // if(rng2D( id.xy, Frame^8 )*rng2D( id.xy, Frame ) > .97)
    // uint2 midPoint = uint2( (uint)(Size.x>>1), (uint)(Size.y>>1) ); // bitwise halfing
    // if( id.x == midPoint.x & id.y == midPoint.y )
    {
        Head newHead;
        newHead.position = (float2)id.xy + ( rng2D( id.xy , Frame ) - .5 ) * GRIDWIDTH;
        newHead.direction = float2(0.,1.);
        newHead.speed = 8;
        newHead.state = 1;
        HeadAppendBuffer.Append(newHead);
    }
}
[numthreads(8,8,1)]
void DrawHeads (uint3 id : SV_DispatchThreadID)
{
    Head consumeHead = HeadConsumeBuffer.Consume();
    if( consumeHead.state == 0) return;                                         //If null return
    if( consumeHead.speed < 1. ) return;                                        //If stationary return
    float2 traversal = consumeHead.direction * consumeHead.speed;
    int dx1 = sign( traversal.x ), dx2 = dx1, dy1 = sign( traversal.y ), dy2 = 0;
    int longest  = abs( traversal.x );
    int shortest = abs( traversal.y );
    if (!(longest>shortest)) 
    {
        longest  = abs( traversal.y );
        shortest = abs( traversal.x );
        dy2 = dy1;
        dx2 = 0;
    }
    int numerator = longest >> 1;                                               // bitwise halfing
    for (int i=0, x = consumeHead.position.x, y = consumeHead.position.y; i <= longest; i++ ) 
    {
        int modX = ( x % Size.x + Size.x ) % Size.x;
        int modY = ( y % Size.y + Size.y ) % Size.y;
        //TODO: Detect diagonal Lines intersection
        if(FilterMap[ int2( modX, modY ) ].a == 1. && i!=0 ) return;            //If traversing existing cell return
        FilterMap[ int2( modX, modY ) ] = float4( (consumeHead.direction-.5)*.5+.5, 0., 1. );
        numerator += shortest;
        if ( !( numerator < longest ) ) {
            numerator -= longest;
            x += dx1;
            y += dy1;
        } else {
            x += dx2;
            y += dy2;
        }
    }

    Head appendHead;
    appendHead.direction    = normalize( consumeHead.direction * cInertia + rngVector2( id.x + ( id.y << 4 ), Frame ) * cChaos );
    appendHead.position     = consumeHead.position+consumeHead.direction * consumeHead.speed;
    appendHead.speed        = consumeHead.speed * clInertia + ( rng2D( id.xy, Frame ) * 2. - 1. ) * clChaos ;
    appendHead.state        = 1;
    HeadAppendBuffer.Append(appendHead);

    if(rng256(Frame,id.x)>lDensity)
    {
        Head appendHeadChild;
        appendHeadChild.direction   = normalize( consumeHead.direction * sInertia + rngVector2(  id.x + ( id.y << 4 ), Frame + 256 ) * sChaos);
        appendHeadChild.position    = consumeHead.position+consumeHead.direction * consumeHead.speed;
        appendHeadChild.speed       = consumeHead.speed * slInertia + ( rng2D( id.xy, Frame + 256 ) * 2. - 1. ) * slChaos ;
        appendHeadChild.state       = 1;
        HeadAppendBuffer.Append(appendHeadChild);
    }
}

// Append Consume Debug Drawer
// [numthreads(8,8,1)]
// void DrawHeads (uint3 id : SV_DispatchThreadID)
// {
//     Head consumeHead = HeadConsumeBuffer.Consume();
//     uint2 posID = (uint2)consumeHead.position;
//     if( FilterMap[posID].r == 1. )
//     {
//         FilterMap[posID] = float4( 0., 1., 0., 1. );
//     }
//     else
//     {
//         FilterMap[posID] = float4( 1., 0., 0., 1. );
//     }
//     HeadAppendBuffer.Append(consumeHead);
// }

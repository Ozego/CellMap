#pragma kernel Clear
#pragma kernel GetHeads
#pragma kernel DrawHeads
#include "rngInclude.compute"

struct Head
{
    float2 position;
    float2 direction;
};
/*
HeightMap Structure:
Red     Blue    Green   Alpha
Height  ddX     ddY     Unmapped

Tag                             Name                                            */
Texture2D<float4>               HeightMap;
RWTexture2D<float4>             FilterMap;
Texture2D<float4>               BlueNoise;
AppendStructuredBuffer<Head>    HeadAppendBuffer;
ConsumeStructuredBuffer<Head>   HeadConsumeBuffer;
uint2                           Size;
uint                            Frame;
int                             lDensity;
float                           cInertia;
float                           sInertia;
float                           cChaos;
float                           sChaos;

[numthreads(8,8,1)]
void Clear (uint3 id : SV_DispatchThreadID)
{
    FilterMap[id.xy] = float4( 0., 0., 0., 1. );
}
[numthreads(8,8,1)]
void GetHeads (uint3 id : SV_DispatchThreadID)
{
    uint2 noiseDimensions;
    BlueNoise.GetDimensions( noiseDimensions.x , noiseDimensions.y );
    float4 noiseVal = BlueNoise[ id.xy % noiseDimensions ];
    // [branch] if(noiseVal.r>.99)
    uint2 midPoint = uint2( Size.x>>1, Size.y>>1 ); // bitwise halfing
    if( id.x == midPoint.x|id.y == 0 )
    {
        Head newHead;
        newHead.position = (float2)id.xy;
        newHead.direction = float2(0.,0.);
        HeadAppendBuffer.Append(newHead);
    }
}
[numthreads(8,8,1)]
void DrawHeads (uint3 id : SV_DispatchThreadID)
{
    Head dHead = HeadConsumeBuffer.Consume();
    if(dHead.position.x==0&&dHead.position.y==0) return; //If null return

    int dx1 = sign( dHead.direction.x ), dx2 = dx1, dy1 = sign( dHead.direction.y ), dy2 = 0;
    int longest = abs( dHead.direction.x );
    int shortest = abs( dHead.direction.y );
    if (!(longest>shortest)) 
    {
        longest = abs( dHead.direction.y );
        shortest = abs( dHead.direction.x );
        dy2 = dy1;
        dx2 = 0;
    }
    int numerator = longest >> 1; // bitwise halfing
    for (int i=0, x = dHead.position.x, y = dHead.position.y; i < longest; i++ ) 
    {
        int modX = ( x % Size.x + Size.x ) % Size.x;
        int modY = ( y % Size.y + Size.y ) % Size.y;
        if(FilterMap[ int2( modX, modY ) ].g == 1. ) 
        {
            // FilterMap[ int2( modX, modY ) ] = float4( 1., 0., 0., 1. );
            return;
        }
        FilterMap[ int2( modX, modY ) ] = float4( 0., 1., 0., 1. );
        numerator += shortest;
        if ( !( numerator < longest ) ) {
            numerator -= longest;
            x += dx1;
            y += dy1;
        } else {
            x += dx2;
            y += dy2;
        }
    }

    Head outHead;
    outHead.direction = dHead.direction*cInertia+rngVector2(Frame, id.x^id.y)*cChaos;
    outHead.position = dHead.position+dHead.direction;
    HeadAppendBuffer.Append(outHead);

    if(rng256(Frame,id.x)>lDensity)
    {
        Head outHeadS;
        outHeadS.direction = dHead.direction*sInertia+rngVector2(Frame, id.x^id.y)*cChaos;
        outHeadS.position = dHead.position+dHead.direction;
        HeadAppendBuffer.Append(outHeadS);
    }
}

// Append Consume Debug Drawer
// [numthreads(8,8,1)]
// void DrawHeads (uint3 id : SV_DispatchThreadID)
// {
//     Head dHead = HeadConsumeBuffer.Consume();
//     uint2 posID = (uint2)dHead.position;
//     if( FilterMap[posID].r == 1. )
//     {
//         FilterMap[posID] = float4( 0., 1., 0., 1. );
//     }
//     else
//     {
//         FilterMap[posID] = float4( 1., 0., 0., 1. );
//     }
//     HeadAppendBuffer.Append(dHead);
// }
